spring:
  application:
    name: mcs-customers # <-- ¡Nombre lógico del microservicio!
  config:
    # Configuración de importación. Spring usará el perfil activo para completar la URL.
    import: "optional:configserver:http://config-server:8888"
  cloud:
      # CRUCIAL: Apuntar al Config Server usando su nombre de servicio en la red de Docker/Kubernetes
    config:
      fail-fast: true # Detiene el inicio si no puede conectarse al Config Server (recomendado).
      retry:                         # Configuración de reintentos para la conexión al Config Server
        max-attempts: 20
        max-interval: 5000
        initial-interval: 1000
    stream:
      kafka:
        binder:
          brokers: kafka:9092 # Apunta al servicio de Kafka en Docker
      bindings:
        # Nombre de la función que produce el mensaje (usada en StreamBridge)
        # -out-0 es la convención para la salida 0
        sendCustomerCreatedEvent-out-0:
          destination: customers.v1.events # Nombre del topic en Kafka

server:
  port: 8080 # Le dice a Spring Boot que use un puerto dinámico (ideal para Kubernetes/Docker)
  # El context-path será manejado por el API Gateway

springdoc:
  swagger-ui:
    path: /swagger-ui.html # Ruta para la UI (puedes cambiarla si quieres)
  packages-to-scan: py.com.yensei.mcs.customers.controllers # Escanea solo los controladores para generar la doc

management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus # Exponer el endpoint de Prometheus
---
spring:
  jpa:
    hibernate:
      ddl-auto: create  # create | update | validate | none
    show-sql: true