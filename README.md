# spring-cloud-2025
## CONFIG SERVER
Sirve para almacenar configuracion de cada componente 
### Actuators
* [/actuator/health](http://localhost:8888/actuator/health) *Ver el status del container*
* [/actuator/refresh](http://localhost:8888/actuator/refresh) *Resetea el cache*, cuando se cambia una configuracion en el remoto muchas veces queda cacheado, ahi hay que usar refresh para forzar el valor actualizado del remoto
### Configuraciones 
Las configuraciones deben est√°r en el repositorio remoto o local pero debe ser GIT, tomar√° precedencia este por sobre el application.yml del proyecto 
* MCS.orders => http://localhost:8888/mcs-orders/dev
* MCS.customers => http://localhost:8888/mcs-customers/dev

## Eureka Server 
* http://localhost:8761/

## MCS customers
Microservicio para la gestion de clientes. En 
[Swagger](http://localhost:8080/mcs-customers/swagger-ui/index.html) la documentaci√≥n para su uso.


## MCS orders
Microservicio para la gestion de pedidos(compras). En 
[Swagger](http://localhost:8081/mcs-orders/swagger-ui/index.html) la documentaci√≥n para su uso.


## Postgres 
Se crea una BD por componente pero actualmente est√°n en el mismo container POSTGREs
### Como levantar una consola
`docker exec -it db-postgres sh`
### Utilizar PSQL
```bash
#Conectar
psql -U user -d orderdb #√≥ customerdb 
#Hacer un query
SELECT * FROM t_order;
#Ver la estructura de la tabla 
\d t_order
#Salir de PSQL
\q
#Salir de container
exit

```

## Monitoreo
### Prometheus
Prometheus es el coraz√≥n del monitoreo de m√©tricas. Su trabajo es "raspar" (hacer scrape) peri√≥dicamente los endpoints /actuator/prometheus que tus microservicios ahora exponen
http://localhost:9090

http://localhost:9090/targets 

#### Ajustar configuraciones de prometheus
```bash
#Permite tomar la nueva configuracion y no volver a despegar todos los containers
docker compose up -d --force-recreate prometheus
```

### Grafana
Grafana es tu centro de visualizaci√≥n. Usar√° los datos de Prometheus (m√©tricas) y Loki (logs) para crear gr√°ficos y dashboards.

* Abre Grafana: Ve a http://localhost:3000.
* Inicia sesi√≥n: El usuario es admin y la contrase√±a es admin (la configuramos en el docker-compose.yml). 
* Verifica las "Data Sources":
* En el men√∫ de la izquierda, ve al √≠cono de la tuerca (‚öôÔ∏è Administration).
Haz clic en Data sources. Deber√≠as ver Prometheus y Loki listados ya que grafana se autoconfigur√≥ para conectarse a ellos

#### La vista "Explore" de Grafana es ideal para jugar con los datos.

* Abre "Explore": En el men√∫ de la izquierda, haz clic en el √≠cono de la br√∫jula (üß≠ Explore).
* Selecciona Prometheus: En la parte superior izquierda, aseg√∫rate de que el desplegable muestre Prometheus.
* Construye una consulta:
* Haz clic en el bot√≥n Metrics browser.
** Escribe jvm_memory_used_bytes y selecci√≥nala. Esta m√©trica muestra el uso de memoria de la JVM para cada servicio.
* Haz clic en Run query en la esquina superior derecha.
** ¬°Ver√°s un gr√°fico en tiempo real del uso de memoria de tus aplicaciones! Puedes filtrar por job o instance para ver un servicio espec√≠fico.
#### Importar tu Primer Dashboard
La verdadera potencia de Grafana est√° en los dashboards. Vamos a importar uno muy popular para aplicaciones Java.

* Ve a la secci√≥n de Dashboards: En el men√∫ de la izquierda, haz clic en el √≠cono de los cuatro cuadrados (‚äû Dashboards).
* Inicia la importaci√≥n: En la esquina superior derecha, haz clic en New -> Import.
* Importar desde Grafana.com: En el campo "Import via grafana.com", pega el ID: 4701 y haz clic en Load.
* Configura el Dashboard:
* En la parte inferior, te pedir√° seleccionar la fuente de datos de Prometheus. Elige Prometheus en el desplegable.
* Haz clic en Import.

## Autenticacion
### Keykloack
Paso 0: Crear el Realm
Al iniciar Keycloak por primera vez, solo existe el realm `master`. Debemos crear uno espec√≠fico para nuestra aplicaci√≥n.

1.  **Accede a la Consola de Administraci√≥n:** Ve a `http://localhost:9990` (user: `admin`, pass: `admin`).
2.  **Crea el Realm:**
    *   En la esquina superior izquierda, haz clic sobre el nombre del realm actual (`master`).
    *   Haz clic en el bot√≥n **Create Realm**.
    *   En **Realm name**, escribe `spring-cloud-realm`.
    *   Haz clic en **Create**.

Keycloak te cambiar√° autom√°ticamente al nuevo realm. Todos los pasos siguientes se realizan dentro de `spring-cloud-realm`.

Paso 1: Configurar un Cliente y Usuario en Keycloak
Primero, necesitamos decirle a Keycloak que existir√° una "aplicaci√≥n cliente" (en este caso, Postman) que solicitar√° tokens, y crear un usuario que pueda iniciar sesi√≥n.

Accede a la Consola de Keycloak:

Abre tu navegador y ve a http://localhost:9990.
Inicia sesi√≥n en la consola de administraci√≥n (usuario: admin, contrase√±a: admin).
Selecciona tu Realm:

En la esquina superior izquierda, aseg√∫rate de que el realm seleccionado sea spring-cloud-realm.
Crea un Cliente para Postman:

En el men√∫ de la izquierda, ve a Clients y haz clic en Create client.
Client ID: postman-client (o el nombre que prefieras).
Deja el resto como est√° y haz clic en Next.
Activa la opci√≥n Client authentication y Direct access grants. Esto es crucial para permitir el flujo de grant_type=password que usaremos.
Haz clic en Save.
Crea un Usuario de Prueba:

En el men√∫ de la izquierda, ve a Users y haz clic en Add user.
Username: testuser.
Haz clic en Create.
Ahora, ve a la pesta√±a Credentials del usuario que acabas de crear.
Haz clic en Set password.
Password: password (o la que quieras).
**MUY IMPORTANTE:** Desactiva la opci√≥n **Temporary**. Si se queda activada, recibir√°s el error "Account is not fully set up".
Haz clic en Save.
¬°Listo! Ya tienes un cliente (postman-client) y un usuario (testuser) listos para autenticarse.

Paso 2: Obtener el Token JWT con Postman
Ahora vamos a pedirle a Keycloak que nos d√© un token para testuser.

Crea una nueva petici√≥n en Postman:

M√©todo: POST
URL: http://localhost:9990/realms/spring-cloud-realm/protocol/openid-connect/token
Configura el Body:

Selecciona la pesta√±a Body.
Elige el tipo x-www-form-urlencoded.
A√±ade las siguientes claves (keys) y valores (values).

*   `grant_type`: `password`
*   `client_id`: `postman-client` (o el nombre de tu cliente)
*   `username`: `testuser`
*   `password`: `password`
*   `client_secret`: (A√±ade esto **solo si tu cliente es confidencial**). Para obtenerlo, ve a la pesta√±a `Credentials` de tu cliente en Keycloak.

Tu configuraci√≥n deber√≠a verse as√≠:

Env√≠a la petici√≥n:

Haz clic en Send.
Si todo est√° correcto, Keycloak te devolver√° una respuesta JSON con varios tokens. El que nos interesa es el access_token.
json
 Show full code block 
{
    "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCIg... (un token muy largo) ...",
    "expires_in": 300,
    "refresh_expires_in": 1800,
    "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCIg...",
    "token_type": "Bearer",
    "not-before-policy": 0,
    "session_state": "...",
    "scope": "email profile"
}
Paso 3: Usar el Token para Acceder a un Endpoint Protegido
Ahora que tienes el access_token, puedes usarlo para autenticarte en tus microservicios a trav√©s del Gateway.

Copia el access_token: Selecciona y copia el valor completo del access_token de la respuesta anterior.

Crea una nueva petici√≥n para tu API:

M√©todo: GET (o el que quieras probar)
URL: http://localhost:8090/api/customers (recuerda usar el puerto del Gateway y la ruta /api/...)
Configura la Autorizaci√≥n:

Ve a la pesta√±a Authorization.
En el desplegable Type, selecciona Bearer Token.
En el campo Token de la derecha, pega el access_token que copiaste.
Env√≠a la petici√≥n:

Haz clic en Send.
¬°Y voil√†! Esta vez, en lugar de un 401 Unauthorized, deber√≠as recibir una respuesta 200 OK con los datos de tu microservicio. El Gateway ha validado el token, ha visto que es correcto y ha permitido que la petici√≥n contin√∫e hasta mcs-customers.

Alternativa con curl (para la terminal)
Si prefieres la l√≠nea de comandos, estos son los comandos equivalentes:

1. Obtener el Token:

```bash
 #Show full code block 
curl --location 'http://localhost:9990/realms/spring-cloud-realm/protocol/openid-connect/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'client_id=postman-client' \
--data-urlencode 'username=testuser' \
--data-urlencode 'password=password' \
--data-urlencode 'grant_type=password'
```
2. Usar el Token: (Reemplaza TU_TOKEN_AQUI con el access_token obtenido)
```bash
curl --location 'http://localhost:8090/api/customers' \
--header 'Authorization: Bearer TU_TOKEN_AQUI'
```
# Con esto ya tienes el flujo completo de autenticaci√≥n y autorizaci√≥n funcionando. ¬°Felicidades!